# 19장: 정책과 수준

## 서론

1. 소프트웨어 시스템이란 정책을 기술한 것
2. 대다수의 주요 시스템에서 하나의 정책은 해당 정책을 서술하는 여러개의 조그만 정책으로 쪼갤 수 있다
3. 소프트웨어 아키텍처를 개발하는 기술에는 이러한 정책을 신중히 분리하고 재편성하는 일도 포함된다.
4. **동일한 이유로 동일한 시점에 변경되는 정책은 동일한 수준, 동일한 컴포넌트에 속해야 하고 다른 시점에 변경되는 정책은 다른 수준, 다른 컴포넌트에 속해야 한다.**
5. **좋은 아키텍처라면 각 컴포넌트를 연결할 때 의존성의 방향이 컴포넌트의 수준을 기반으로 연결되어야 한다 (저수준 컴포넌트가 고수준 컴포넌트에 의존하도록)**

## 본론

### 수준

1. 입력과 출력까지의 거리라고 정의할 수 있음
2. 시스템의 입력과 출력 모두로부터 멀어질 수록 정책의 수준이 높아진다.
3. 소스코드의 의존성은 데이터 흐름이 아닌 그 수준에 따라 결합 되어야 한다. (따라서 데이터의 흐름과 소스코드의 의존성이 항상 같은 방향을 가리키지 않는다)

# 20장: 업무 규칙

## 서론

1. 업뮤규칙은 사업적으로 수익을 얻거나 비용을 줄일 수 있는 규칙 또는 절차이다. (프로그램을 구현하였는지와는 관계가 없음)
2. 1.과 같은 규칙은 **핵심 업무 규칙**이라 부름(시스템이 존재하지 않더라도 그대로 존재하기 때문에)
3. 핵심 업무 규칙은 보통 데이터를 요구한다. (시스템이 자동화 되지 않은 경우에도 존재하는 데이터)
4. 핵심 규칙과 데이터는 본질적을 결합되어 있기 때문에 객첼 만들기 좋은 후보가 되며 이러한 데이터를 **entity** 라고 부름

## 본론

### entity

1. 시스템 내부의 객체로써 핵심 업무 데이터를 기반으로 동작하는 조그만 핵심 업무 규칙을 구체화 한다.
2. entity 객체는 핵심 업무 데이터를 직접 포함하거나 핵심 업무 데이터에 매우 쉽게 접근할 수 있다.
3. entity의 interface는 핵심 업무 데이터를 기반으로 동작하는 핵심 업무 규칙을 구현한 함수들로 구성된다.
4. 이러한 클래스를 생성할 때 업무에 핵심적인 개념을 구현하려는 소프트웨어는 한데 **모으고** 나머지 모든 고려사항과 **분리** 시킨다.
5. 위 클래스는 업무의 대표자로서 독립적으로 존재하며 외부 고려사항에 의해 오염되어서는 절대 안된다.
6. entity가 클래스일 필요는 없으며 유일한 요구조건은 핵심 업무 데이터와 핵심 업무 규칙을 하날 묶어 별도의 소프트웨어 모듈로 만들어야 한다는 것

### 유스케이스

1. 자동화된 시스템이 동작하는 방법을 정의, 제약함으로써 만들어지는 업무 규칙도 존재하며 이러한 업무 규칙을 **유스케이스** 라고 한다.
2. 유스케이스는 엔티티 내부의 핵심 업무 규칙으 어떻게, 언제 호출할지를 명시하는 규칙을 담는다. (**사용자 인터페이스를 명시하지 않음**)
3. 엔티티는 자신을 제어하는 유스케이스에 대해서 아무것도 알지 못한다.
4. 유스케이스는 entity에 의존하는 반면 entity는 유스케이스에 의존하지 않기 때문에 entity가 더 고수준임

### 요청 및 응답 모델

1. 유스케이스는 어떤 사용자 인터페이스에도 종속되지 않는다.
2. 요청 및 응답 모델이 독립적이지 않다면, 그 모델에 의존하는 유스케이스도 결국 해당 모델이 수반하는 의존성에 간접적으로 결합되기 때문

# 21장: 소리치는 아키텍처

## 본론

### 아키텍처의 테마

1. 소프트웨어 애플리케이션의 아키텍처가 애플리케이션의 유스케이스에 소리쳐야한다.
2. 아키텍처는 프레임워크에 대한 것이 아니다. (프레임워크는 도구일 뿐 아키텍처가 준수하 대상이 아님)
3. 아키텍처를 프레임워크 중심으로 만들면 유스케이스가 중심이 되는 아키텍처는 절대 나올 수 없다.

### 아키텍처의 목적

1. 좋은 소프트웨어 아키텍처는 여러 개발 환경의 문제나 도구에 대한 결정을 미룰 수 있게 만들어준다. (프레임워크는 열어두어야 할 선택사항이다.)
2. 또한 위의 결정을 쉽게 번복할 수 있도록 만들어준다.

### 하지만 웹은?

1. 웹은 전달 매커니즘(입출력 장치) 이며 애플리케이션 아키텍처에서도 그와 같이 다루어야 한다.
2. 애플리케이션이 웹을 통해 전달된다는 사실은 세부사항이며, 시스템 구조를 지배해서는 안된다.

### 프레임워크는 도구일 뿐

1. 프레임워크가 모든 것을 하게 하자 라는 태도는 우릭 취하고 싶은 태도가 아니다.

### 테스트하기 쉬운 아키텍처

1. 아키텍처가 유스케이스를 최우선으로 한다면, 프레임워크를 전혀 준비하지 않더라도 필요한 유스케이스 전부에 대해 단위 테스트를 할 수 있어야 한다.
2. 테스트를 돌리는 데 웹 서벅 반드시 필요한 상황이 되어서는 안 된다.

# 22장: 클리 아키텍처

## 서론

1. 아키텍처의 목표는 **관심사의 분리** 이다.
2. 아키텍처는 시스템이 아래와 같은 특징을 지니도록 만든다.
    1. 프레임워크 독립성
    2. 테스트 용이성
    3. UI 독립성
    4. 데이터페이스 독립성
    5. 모드 외부 에이전시에 대한 독립성

## 본론
![image](https://user-images.githubusercontent.com/52348220/227779614-d4167b23-aff3-4a4f-8488-9cc95ef2a1dd.png)

### 의존성 규칙

1. 이미지의 각각의 동심원은 소프트웨어에서 서로 다른 영역을 표시하며 보통 안으로 들어갈 수록 고수준의 소프트웨어가 된다. (바깥원은 매커니즘이고 안쪽 원은 정책이다)
2. 이러한 아키텍처가 동작하도록 하는 가장 중요한 규칙은 의존성 규칙이다.
3. 소스코드 의존성은 반드시 안쪽으로, 고수준의 정책을 향해야 한다. (내부 원에 속한 코드는 외부 원에 선언된 어떤 것에 대해서도 그 이름을 언급해서는 안된다.)

### entity

1. 다양한 애플리케이션에서 entity를 재사용할 수만 있다면 그 형태는 그다지 중요하지 않다.
2. 전사적이지 않은 단순한 단일 애플리케이션을 작성하고 있다면 entity는 해당 애플리케이션의 업무 객체가 된다.
3. 2.와 같은 경우 entity는 가장 일반적이며 고수준인 규칙을 캡슐화 한다.

### 유스케이스

1. 애플리케이션에 특화된 업무 규칙을 포함한다.
2. 유스케이스 계층의 소프트웨어는 시스템의 모든 유스케이스를 캡슐화 하고 구현한다.
3. 유스케이스는 entity로 들어오고 나가는 데이터 흐름을 조정하며 entity가 자신의 핵심 업무 규칙을 사용해 유스케이스의 목적을 달성하도록 이끈다.
4. 유스케이스 계층에서 발생한 변경이 entity에 영향을 주어서는 안된다.

### 인터페이스 어뎁터

1. 이 계층은 GUI의 MVC 아키텍처를 모두 포괄한다.
2. 이 계층에서는 외부 형식의 데이터를 유스케이스나 entity에서 사용되는 내부 형식으로 변환하는 또다른 어뎁터가 필요하다.

### 프레임워크와 드라이버

1. 이 계층에서는 안쪽 원과 통신하기 위하 접합 코드 이외에는 특별히 작성해야 할 코드가 많지 않다.

### 경계 횡단하기

1. 아키텍처의 경계를 횡단할 때 언제라도 의존성 역전 원칙을 사용할 수 있다.

### 경계를 횡단하는 데이터의 모습

1. entity의 객체나 데이터베이스의 행을 전달하는것은 올바르지 않다.
2. 따라서 데이터를 전달하 때에는 항상 내부의 원에서 사용하기에 가장 편리한 형태를 가져야 한다.

